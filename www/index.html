<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- including ECharts file -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@4.6.0/dist/echarts.min.js"></script>
    <script src="./colors.js"></script>
    <script src="./gauge.js"></script>
    <script src="./line.js"></script>

    <link href="monitor.css" rel="stylesheet" type="text/css">
</head>

<body>
<!-- preparing a DOM with width and height for ECharts -->
<div class="chart" id="main"></div>
<div class="details">
    <div id="server"></div>
    <div id="response">
        <div id="settings">Settings</div>
        Failures:
        <div id="failure"></div>
        Successes:
        <div id="success"></div>
    </div>
</div>
<div class="settings">
    <div id="save">Save Settings</div>
    <textarea></textarea>
</div>

<script type="text/javascript">
    const chart = echarts.init(document.getElementById('main'));
    const data = [];
    let serverIPs = {};
    let clicked = false;
    let connection;

    chart.on("click", function (clickEvent) {
        if (clicked) {
            return;
        }
        document.querySelector(".details").classList.remove("half");
        document.querySelector(".settings").classList.remove("half");

        clicked = true;
        const serverName = clickEvent.treePathInfo[1].name;
        if (serverIPs.hasOwnProperty(serverName)) {
            connection = serverIPs[serverName];
        } else {
            connection = currentServer();
        }
        document.getElementById("server").textContent = serverName;
        document.getElementById("failure").textContent = "Updating, please wait...";
        document.getElementById("success").textContent = "Updating, please wait...";
        document.querySelector(".chart").classList.add("half");
        document.querySelector(".details").classList.add("half");
        requestAnimationFrame(function () {
            chart.resize();
            enableSettingsButton();
        });
        fetchDetails();
    });

    function enableSettingsButton() {
        const elem = document.getElementById("settings");
        if (elem.classList.contains("active")) {
            return;
        }
        elem.classList.add("active");
        elem.addEventListener("click", function () {
            showSettings();
        });
    }

    function enableSaveButton() {
        const elem = document.getElementById("save");
        if (elem.classList.contains("active")) {
            return;
        }
        elem.classList.add("active");
        elem.addEventListener("click", function () {
            saveSettings();
        });
    }

    function showSettings() {
        document.querySelector(".details").classList.remove("half");
        document.querySelector(".settings").classList.add("half");

        clicked = true;
        fetchSettings();
    }

    function saveSettings() {
        clicked = true;
        const data = document.querySelector(".settings > textarea").value;
        fetch("http://" + connection + "/config?persist=true", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: data
        }).then((response) => {
            console.log(response);
            clicked = false;
        }).catch((e) => {
            console.log(e);
            clicked = false;
        });
    }

    function currentServer() {
        return window.location.href.split("/www/")[0];
    }

    function colorNode(state) {
        return {
            borderColor: state ? colorOk : colorNg,
            shadowColor: state ? colorOk : colorNg
        };
    }

    function colorNodeLabel(state) {
        return {
            color: state ? colorOk : colorNg
        };
    }

    function fetchDetails() {
        fetch("http://" + connection + "/status")
            .then((response) => {
                return response.json();
            })
            .then((response) => {
                formatReports(
                    response.status.success,
                    document.getElementById("success"));
                formatReports(
                    response.status.failure,
                    document.getElementById("failure"));
                clicked = false;

            })
            .catch((e) => {
                document.getElementById("failure").textContent = JSON.stringify(e, null, 4);
                clicked = false;
            });
    }

    function fetchSettings() {
        requestAnimationFrame(function () {
            enableSaveButton();
        });
        fetch("http://" + connection + "/config")
            .then((response) => {
                return response.json();
            })
            .then((response) => {
                document.querySelector(".settings > textarea").value = JSON.stringify(response, null, 4);
                clicked = false;

            })
            .catch((e) => {
                document.getElementById("failure").textContent = JSON.stringify(e, null, 4);
                clicked = false;
            });
    }

    function formatReports(reports, node) {
        while (node.hasChildNodes()) {
            node.removeChild(node.firstChild);
        }

        for (let i = 0; i < reports.length; i++) {
            const element = document.createElement("div");
            element.classList.add("monitor");
            element.appendChild(formatReportTitle(reports[i]));
            element.appendChild(formatReportDetails(reports[i]));
            node.appendChild(element);
        }
    }

    function formatReportTitle(report) {
        const element = document.createElement("div");
        element.classList.add("report-title");
        element.appendChild(document.createTextNode(report.title));
        return element;
    }

    function formatReportDetails(report) {
        const element = document.createElement("ul");
        element.classList.add("report-details");
        const details = report.details;
        const keys = Object.keys(details);

        const hidden = [];

        for (let i = 0; i < keys.length; i++) {
            const entry = details[keys[i]];
            if (isHistory(entry)) {
                const sub = document.createElement("li");
                element.appendChild(sub);
                const values = entry["values"];
                const dates = entry["dates"];
                const max = parseInt(entry["max"]);
                const limit = parseInt(entry["limit"]);
                sub.appendChild(makeLine(values, dates, max, limit));
                hidden.push(keys[i]);
            }
        }

        if (keys.indexOf("Current Usage") !== -1 && keys.indexOf("Maximum Usage") !== -1) {
            const sub = document.createElement("li");
            element.appendChild(sub);
            const current = parseInt(details["Current Usage"]);
            const max = parseInt(details["Maximum Usage"]);
            sub.appendChild(makeGauge(current, max));
        }

        for (let i = 0; i < keys.length; i++) {
            if (hidden.indexOf(keys[i]) > -1) {
                continue;
            }
            const sub = document.createElement("li");
            element.appendChild(sub);

            const detail = document.createElement("span");
            const key = document.createElement("span");
            key.classList.add("key");
            key.appendChild(document.createTextNode(keys[i] + ": "));
            detail.appendChild(key);
            const value = document.createElement("span");
            value.classList.add("value");
            value.appendChild(document.createTextNode(details[keys[i]]));
            detail.appendChild(value);
            sub.appendChild(detail);
        }
        return element;
    }

    function isHistory(value) {
        return value.hasOwnProperty("type") && value["type"] === "history";
    }

    function getServerState() {
        fetch(currentServer() + "/status/cluster")
            .then((response) => {
                return response.json();
            })
            .then((response) => {
                const cluster = response.clusterStatus;
                serverIPs = response.connections;

                data.length = 0;
                const servers = Object.keys(cluster);
                servers.sort();
                for (let i = 0; i < servers.length; i++) {
                    const server = servers[i];
                    const status = cluster[server];

                    const children = [];
                    const monitors = Object.keys(status);
                    monitors.sort();
                    let allOk = true;
                    for (let j = 0; j < monitors.length; j++) {
                        const monitorName = monitors[j];
                        const state = status[monitorName];
                        if (!state) {
                            allOk = false;
                        }
                        children.push({
                            name: monitorName,
                            value: state ? 1 : 2,
                            nodeClick: false,
                            itemStyle: colorNode(state),
                            label: colorNodeLabel(state)
                        });
                    }

                    data.push({
                        name: server,
                        children: children,
                        nodeClick: false,
                        itemStyle: colorNode(allOk),
                        label: colorNodeLabel(allOk)
                    });
                }

                const baseItemStyle = {
                    color: "transparent",
                    shadowBlur: 10,
                    borderWidth: 4
                };

                const option = {
                    label: {
                        rotate: 'radial',
                        color: bgColor,
                        fontSize: 20
                    },
                    tooltip: {},
                    series: [{
                        type: 'sunburst',
                        sort: null,
                        center: ['50%', '50%'],
                        levels: [
                            {},
                            {
                                r0: "15%",
                                r: "50%",
                                itemStyle: baseItemStyle
                            },
                            {
                                r0: "52%",
                                r: "54%",
                                itemStyle: baseItemStyle,
                                label: {
                                    position: 'outside',
                                    padding: 3
                                }
                            }
                        ],
                        data: data
                    }],
                    itemStyle: {
                        borderColor: bgColor,
                        borderWidth: 2
                    }
                };

                chart.setOption(option);
            });
    }

    function refresh() {
        getServerState();
        const panel = document.querySelector(".details.half");
        if (panel && connection) {
            fetchDetails();
        }
    }

    getServerState();
    setInterval(refresh, 30_000);
</script>
</body>
</html>